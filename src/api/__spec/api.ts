/* tslint:disable */
/* eslint-disable */
/**
 * Clinic App
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap
} from './base';

/**
 *
 * @export
 * @interface Appointment
 */
export interface Appointment {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  appointment_date?: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  diagnosis?: string;
  /**
   *
   * @type {AppointmentEdges}
   * @memberof Appointment
   */
  edges: AppointmentEdges;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  end_time?: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  notes?: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  payment_status?: string;
  /**
   *
   * @type {Array<object>}
   * @memberof Appointment
   */
  prescriptions?: Array<object>;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  start_time?: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  symptoms?: string;
  /**
   *
   * @type {number}
   * @memberof Appointment
   */
  total_cost?: number;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  treatment_plan?: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface AppointmentEdges
 */
export interface AppointmentEdges {
  /**
   *
   * @type {Clinic}
   * @memberof AppointmentEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {Doctor}
   * @memberof AppointmentEdges
   */
  doctor?: Doctor;
  /**
   *
   * @type {Array<OrderItem>}
   * @memberof AppointmentEdges
   */
  order_items?: Array<OrderItem> | null;
  /**
   *
   * @type {Patient}
   * @memberof AppointmentEdges
   */
  patient?: Patient;
  /**
   *
   * @type {Array<AppointmentReminder>}
   * @memberof AppointmentEdges
   */
  reminders?: Array<AppointmentReminder> | null;
  /**
   *
   * @type {Service}
   * @memberof AppointmentEdges
   */
  service?: Service;
}
/**
 *
 * @export
 * @interface AppointmentReminder
 */
export interface AppointmentReminder {
  /**
   *
   * @type {string}
   * @memberof AppointmentReminder
   */
  created_at?: string;
  /**
   *
   * @type {AppointmentReminderEdges}
   * @memberof AppointmentReminder
   */
  edges: AppointmentReminderEdges;
  /**
   *
   * @type {string}
   * @memberof AppointmentReminder
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AppointmentReminder
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof AppointmentReminder
   */
  scheduled_time?: string;
  /**
   *
   * @type {string}
   * @memberof AppointmentReminder
   */
  sent_at?: string;
  /**
   *
   * @type {string}
   * @memberof AppointmentReminder
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof AppointmentReminder
   */
  type?: string;
}
/**
 *
 * @export
 * @interface AppointmentReminderEdges
 */
export interface AppointmentReminderEdges {
  /**
   *
   * @type {Appointment}
   * @memberof AppointmentReminderEdges
   */
  appointment?: Appointment;
}
/**
 *
 * @export
 * @interface BillingRecord
 */
export interface BillingRecord {
  [key: string]: any;

  /**
   *
   * @type {number}
   * @memberof BillingRecord
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof BillingRecord
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof BillingRecord
   */
  currency?: string;
  /**
   *
   * @type {number}
   * @memberof BillingRecord
   */
  discount_amount?: number;
  /**
   *
   * @type {string}
   * @memberof BillingRecord
   */
  due_date?: string;
  /**
   *
   * @type {BillingRecordEdges}
   * @memberof BillingRecord
   */
  edges: BillingRecordEdges;
  /**
   *
   * @type {string}
   * @memberof BillingRecord
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof BillingRecord
   */
  invoice_number?: string;
  /**
   *
   * @type {Array<object>}
   * @memberof BillingRecord
   */
  line_items?: Array<object>;
  /**
   *
   * @type {string}
   * @memberof BillingRecord
   */
  notes?: string;
  /**
   *
   * @type {string}
   * @memberof BillingRecord
   */
  paid_at?: string;
  /**
   *
   * @type {string}
   * @memberof BillingRecord
   */
  payment_method?: string;
  /**
   *
   * @type {string}
   * @memberof BillingRecord
   */
  payment_status?: string;
  /**
   *
   * @type {number}
   * @memberof BillingRecord
   */
  tax_amount?: number;
  /**
   *
   * @type {number}
   * @memberof BillingRecord
   */
  total_amount?: number;
  /**
   *
   * @type {string}
   * @memberof BillingRecord
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface BillingRecordEdges
 */
export interface BillingRecordEdges {
  /**
   *
   * @type {Clinic}
   * @memberof BillingRecordEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {Patient}
   * @memberof BillingRecordEdges
   */
  patient?: Patient;
}
/**
 *
 * @export
 * @interface ChatMessage
 */
export interface ChatMessage {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof ChatMessage
   */
  ai_tool_call?: string;
  /**
   *
   * @type {object}
   * @memberof ChatMessage
   */
  ai_tool_result?: object;
  /**
   *
   * @type {string}
   * @memberof ChatMessage
   */
  content?: string;
  /**
   *
   * @type {string}
   * @memberof ChatMessage
   */
  created_at?: string;
  /**
   *
   * @type {ChatMessageEdges}
   * @memberof ChatMessage
   */
  edges: ChatMessageEdges;
  /**
   *
   * @type {string}
   * @memberof ChatMessage
   */
  id?: string;
  /**
   *
   * @type {boolean}
   * @memberof ChatMessage
   */
  is_read?: boolean;
  /**
   *
   * @type {string}
   * @memberof ChatMessage
   */
  message_type?: string;
  /**
   *
   * @type {object}
   * @memberof ChatMessage
   */
  metadata?: object;
  /**
   *
   * @type {string}
   * @memberof ChatMessage
   */
  sender_type?: string;
  /**
   *
   * @type {string}
   * @memberof ChatMessage
   */
  whatsapp_message_id?: string;
}
/**
 *
 * @export
 * @interface ChatMessageEdges
 */
export interface ChatMessageEdges {
  /**
   *
   * @type {ChatThread}
   * @memberof ChatMessageEdges
   */
  thread?: ChatThread;
}
/**
 *
 * @export
 * @interface ChatThread
 */
export interface ChatThread {
  [key: string]: any;

  /**
   *
   * @type {object}
   * @memberof ChatThread
   */
  context?: object;
  /**
   *
   * @type {string}
   * @memberof ChatThread
   */
  created_at?: string;
  /**
   *
   * @type {ChatThreadEdges}
   * @memberof ChatThread
   */
  edges: ChatThreadEdges;
  /**
   *
   * @type {string}
   * @memberof ChatThread
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ChatThread
   */
  last_message_at?: string;
  /**
   *
   * @type {string}
   * @memberof ChatThread
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof ChatThread
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof ChatThread
   */
  whatsapp_thread_id?: string;
}
/**
 *
 * @export
 * @interface ChatThreadEdges
 */
export interface ChatThreadEdges {
  /**
   *
   * @type {Clinic}
   * @memberof ChatThreadEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {Array<ChatMessage>}
   * @memberof ChatThreadEdges
   */
  messages?: Array<ChatMessage> | null;
  /**
   *
   * @type {Patient}
   * @memberof ChatThreadEdges
   */
  patient?: Patient;
}
/**
 *
 * @export
 * @interface Clinic
 */
export interface Clinic {
  [key: string]: any;

  /**
   *
   * @type {boolean}
   * @memberof Clinic
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Clinic
   */
  address?: string;
  /**
   *
   * @type {object}
   * @memberof Clinic
   */
  business_hours?: object;
  /**
   *
   * @type {string}
   * @memberof Clinic
   */
  created_at?: string;
  /**
   *
   * @type {ClinicEdges}
   * @memberof Clinic
   */
  edges: ClinicEdges;
  /**
   *
   * @type {string}
   * @memberof Clinic
   */
  email?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Clinic
   */
  enabled_features?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Clinic
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Clinic
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Clinic
   */
  phone?: string;
  /**
   *
   * @type {string}
   * @memberof Clinic
   */
  subscription_plan?: string;
  /**
   *
   * @type {string}
   * @memberof Clinic
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof Clinic
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof Clinic
   */
  whatsapp_number?: string;
}
/**
 *
 * @export
 * @interface ClinicEdges
 */
export interface ClinicEdges {
  /**
   *
   * @type {Array<Appointment>}
   * @memberof ClinicEdges
   */
  appointments?: Array<Appointment> | null;
  /**
   *
   * @type {Array<BillingRecord>}
   * @memberof ClinicEdges
   */
  billing_records?: Array<BillingRecord> | null;
  /**
   *
   * @type {Array<ChatThread>}
   * @memberof ClinicEdges
   */
  chat_threads?: Array<ChatThread> | null;
  /**
   *
   * @type {Array<ClinicUser>}
   * @memberof ClinicEdges
   */
  clinic_users?: Array<ClinicUser> | null;
  /**
   *
   * @type {Array<Doctor>}
   * @memberof ClinicEdges
   */
  doctors?: Array<Doctor> | null;
  /**
   *
   * @type {Array<Document>}
   * @memberof ClinicEdges
   */
  documents?: Array<Document> | null;
  /**
   *
   * @type {Array<InventoryMovement>}
   * @memberof ClinicEdges
   */
  inventory_movements?: Array<InventoryMovement> | null;
  /**
   *
   * @type {Array<KnowledgeBase>}
   * @memberof ClinicEdges
   */
  knowledge_base?: Array<KnowledgeBase> | null;
  /**
   *
   * @type {Array<Order>}
   * @memberof ClinicEdges
   */
  orders?: Array<Order> | null;
  /**
   *
   * @type {Array<Patient>}
   * @memberof ClinicEdges
   */
  patients?: Array<Patient> | null;
  /**
   *
   * @type {Array<ProductCategory>}
   * @memberof ClinicEdges
   */
  product_categories?: Array<ProductCategory> | null;
  /**
   *
   * @type {Array<Product>}
   * @memberof ClinicEdges
   */
  products?: Array<Product> | null;
  /**
   *
   * @type {Array<Service>}
   * @memberof ClinicEdges
   */
  services?: Array<Service> | null;
}
/**
 *
 * @export
 * @interface ClinicUser
 */
export interface ClinicUser {
  /**
   *
   * @type {string}
   * @memberof ClinicUser
   */
  clinic_id?: string;
  /**
   *
   * @type {ClinicUserEdges}
   * @memberof ClinicUser
   */
  edges: ClinicUserEdges;
  /**
   *
   * @type {string}
   * @memberof ClinicUser
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ClinicUser
   */
  user_id?: string;
}
/**
 *
 * @export
 * @interface ClinicUserEdges
 */
export interface ClinicUserEdges {
  /**
   *
   * @type {Clinic}
   * @memberof ClinicUserEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {User}
   * @memberof ClinicUserEdges
   */
  user?: User;
}
/**
 *
 * @export
 * @interface CreateAppointmentPayload
 */
export interface CreateAppointmentPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof CreateAppointmentPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface CreateClinicPayload
 */
export interface CreateClinicPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof CreateClinicPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface CreateDoctorPayload
 */
export interface CreateDoctorPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof CreateDoctorPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface CreateFeaturePayload
 */
export interface CreateFeaturePayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof CreateFeaturePayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface CreateOrderPayload
 */
export interface CreateOrderPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof CreateOrderPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface CreatePatientPayload
 */
export interface CreatePatientPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof CreatePatientPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface CreateProductPayload
 */
export interface CreateProductPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof CreateProductPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface CreateQueueEntryPayload
 */
export interface CreateQueueEntryPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof CreateQueueEntryPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface CreateServicePayload
 */
export interface CreateServicePayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof CreateServicePayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface CreateUserPayload
 */
export interface CreateUserPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof CreateUserPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface Doctor
 */
export interface Doctor {
  [key: string]: any;

  /**
   *
   * @type {boolean}
   * @memberof Doctor
   */
  active?: boolean;
  /**
   *
   * @type {object}
   * @memberof Doctor
   */
  availability?: object;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  bio?: string;
  /**
   *
   * @type {number}
   * @memberof Doctor
   */
  consultation_duration?: number;
  /**
   *
   * @type {number}
   * @memberof Doctor
   */
  consultation_fee?: number;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  created_at?: string;
  /**
   *
   * @type {DoctorEdges}
   * @memberof Doctor
   */
  edges: DoctorEdges;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  license_number?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  phone?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Doctor
   */
  qualifications?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  specialization?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface DoctorEdges
 */
export interface DoctorEdges {
  /**
   *
   * @type {Array<Appointment>}
   * @memberof DoctorEdges
   */
  appointments?: Array<Appointment> | null;
  /**
   *
   * @type {Clinic}
   * @memberof DoctorEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {Array<DoctorSchedule>}
   * @memberof DoctorEdges
   */
  schedules?: Array<DoctorSchedule> | null;
}
/**
 *
 * @export
 * @interface DoctorSchedule
 */
export interface DoctorSchedule {
  /**
   *
   * @type {boolean}
   * @memberof DoctorSchedule
   */
  available?: boolean;
  /**
   *
   * @type {string}
   * @memberof DoctorSchedule
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof DoctorSchedule
   */
  date?: string;
  /**
   *
   * @type {DoctorScheduleEdges}
   * @memberof DoctorSchedule
   */
  edges: DoctorScheduleEdges;
  /**
   *
   * @type {string}
   * @memberof DoctorSchedule
   */
  end_time?: string;
  /**
   *
   * @type {string}
   * @memberof DoctorSchedule
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DoctorSchedule
   */
  notes?: string;
  /**
   *
   * @type {string}
   * @memberof DoctorSchedule
   */
  start_time?: string;
}
/**
 *
 * @export
 * @interface DoctorScheduleEdges
 */
export interface DoctorScheduleEdges {
  /**
   *
   * @type {Doctor}
   * @memberof DoctorScheduleEdges
   */
  doctor?: Doctor;
}
/**
 *
 * @export
 * @interface Document
 */
export interface Document {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof Document
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Document
   */
  document_date?: string;
  /**
   *
   * @type {DocumentEdges}
   * @memberof Document
   */
  edges: DocumentEdges;
  /**
   *
   * @type {string}
   * @memberof Document
   */
  file_path?: string;
  /**
   *
   * @type {number}
   * @memberof Document
   */
  file_size?: number;
  /**
   *
   * @type {string}
   * @memberof Document
   */
  file_type?: string;
  /**
   *
   * @type {string}
   * @memberof Document
   */
  id?: string;
  /**
   *
   * @type {boolean}
   * @memberof Document
   */
  is_confidential?: boolean;
  /**
   *
   * @type {object}
   * @memberof Document
   */
  metadata?: object;
  /**
   *
   * @type {string}
   * @memberof Document
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Document
   */
  type?: string;
}
/**
 *
 * @export
 * @interface DocumentEdges
 */
export interface DocumentEdges {
  /**
   *
   * @type {Clinic}
   * @memberof DocumentEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {Patient}
   * @memberof DocumentEdges
   */
  patient?: Patient;
}
/**
 *
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
  /**
   * Where the error occurred, e.g. \'body.items[3].tags\' or \'path.thing-id\'
   * @type {string}
   * @memberof ErrorDetail
   */
  location?: string;
  /**
   * Error message text
   * @type {string}
   * @memberof ErrorDetail
   */
  message?: string;
  /**
   *
   * @type {any}
   * @memberof ErrorDetail
   */
  value?: any;
}
/**
 *
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ErrorModel
   */
  $schema?: string;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof ErrorModel
   */
  detail?: string;
  /**
   * Optional list of individual error details
   * @type {Array<ErrorDetail>}
   * @memberof ErrorModel
   */
  errors?: Array<ErrorDetail> | null;
  /**
   * A URI reference that identifies the specific occurrence of the problem.
   * @type {string}
   * @memberof ErrorModel
   */
  instance?: string;
  /**
   * HTTP status code
   * @type {number}
   * @memberof ErrorModel
   */
  status?: number;
  /**
   * A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
   * @type {string}
   * @memberof ErrorModel
   */
  title?: string;
  /**
   * A URI reference to human-readable documentation for the error.
   * @type {string}
   * @memberof ErrorModel
   */
  type?: string;
}
/**
 *
 * @export
 * @interface Feature
 */
export interface Feature {
  /**
   *
   * @type {boolean}
   * @memberof Feature
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Feature
   */
  category?: string;
  /**
   *
   * @type {string}
   * @memberof Feature
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Feature
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Feature
   */
  display_name?: string;
  /**
   *
   * @type {string}
   * @memberof Feature
   */
  id?: string;
  /**
   *
   * @type {number}
   * @memberof Feature
   */
  monthly_price?: number;
  /**
   *
   * @type {string}
   * @memberof Feature
   */
  name?: string;
}
/**
 *
 * @export
 * @interface InventoryMovement
 */
export interface InventoryMovement {
  /**
   *
   * @type {string}
   * @memberof InventoryMovement
   */
  created_at?: string;
  /**
   *
   * @type {InventoryMovementEdges}
   * @memberof InventoryMovement
   */
  edges: InventoryMovementEdges;
  /**
   *
   * @type {string}
   * @memberof InventoryMovement
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryMovement
   */
  movement_date?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryMovement
   */
  notes?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryMovement
   */
  performed_by?: string;
  /**
   *
   * @type {number}
   * @memberof InventoryMovement
   */
  quantity?: number;
  /**
   *
   * @type {string}
   * @memberof InventoryMovement
   */
  reference_id?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryMovement
   */
  type?: string;
}
/**
 *
 * @export
 * @interface InventoryMovementEdges
 */
export interface InventoryMovementEdges {
  /**
   *
   * @type {Clinic}
   * @memberof InventoryMovementEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {Product}
   * @memberof InventoryMovementEdges
   */
  product?: Product;
}
/**
 *
 * @export
 * @interface KnowledgeBase
 */
export interface KnowledgeBase {
  [key: string]: any;

  /**
   *
   * @type {boolean}
   * @memberof KnowledgeBase
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof KnowledgeBase
   */
  category?: string;
  /**
   *
   * @type {string}
   * @memberof KnowledgeBase
   */
  content?: string;
  /**
   *
   * @type {string}
   * @memberof KnowledgeBase
   */
  created_at?: string;
  /**
   *
   * @type {KnowledgeBaseEdges}
   * @memberof KnowledgeBase
   */
  edges: KnowledgeBaseEdges;
  /**
   *
   * @type {string}
   * @memberof KnowledgeBase
   */
  id?: string;
  /**
   *
   * @type {object}
   * @memberof KnowledgeBase
   */
  metadata?: object;
  /**
   *
   * @type {number}
   * @memberof KnowledgeBase
   */
  priority?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof KnowledgeBase
   */
  tags?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof KnowledgeBase
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof KnowledgeBase
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface KnowledgeBaseEdges
 */
export interface KnowledgeBaseEdges {
  /**
   *
   * @type {Clinic}
   * @memberof KnowledgeBaseEdges
   */
  clinic?: Clinic;
}
/**
 *
 * @export
 * @interface LoginAdminPayload
 */
export interface LoginAdminPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof LoginAdminPayload
   */
  $schema?: string;
  /**
   * Email of the user
   * @type {string}
   * @memberof LoginAdminPayload
   */
  email: string;
  /**
   * Password of the user
   * @type {string}
   * @memberof LoginAdminPayload
   */
  password: string;
}
/**
 *
 * @export
 * @interface LoginOutput
 */
export interface LoginOutput {
  /**
   *
   * @type {string}
   * @memberof LoginOutput
   */
  access_token: string;
  /**
   *
   * @type {number}
   * @memberof LoginOutput
   */
  access_token_expires_at: number;
  /**
   *
   * @type {string}
   * @memberof LoginOutput
   */
  refresh_token: string;
  /**
   *
   * @type {number}
   * @memberof LoginOutput
   */
  refresh_token_expires_at: number;
}
/**
 *
 * @export
 * @interface LoginPayload
 */
export interface LoginPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof LoginPayload
   */
  $schema?: string;
  /**
   * Email of the user
   * @type {string}
   * @memberof LoginPayload
   */
  email: string;
  /**
   * Password of the user
   * @type {string}
   * @memberof LoginPayload
   */
  password: string;
}
/**
 *
 * @export
 * @interface Meta
 */
export interface Meta {
  /**
   * Response status code
   * @type {number}
   * @memberof Meta
   */
  code: number;
  /**
   * Response signature
   * @type {string}
   * @memberof Meta
   */
  signature: string;
  /**
   * Response status
   * @type {string}
   * @memberof Meta
   */
  status: string;
  /**
   * Application version
   * @type {string}
   * @memberof Meta
   */
  version: string;
}
/**
 *
 * @export
 * @interface Order
 */
export interface Order {
  [key: string]: any;

  /**
   *
   * @type {object}
   * @memberof Order
   */
  billing_address?: object;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  cancellation_reason?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  delivered_at?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  delivery_method?: string;
  /**
   *
   * @type {number}
   * @memberof Order
   */
  discount_amount?: number;
  /**
   *
   * @type {OrderEdges}
   * @memberof Order
   */
  edges: OrderEdges;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  expected_delivery_date?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  notes?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  order_number?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  order_type?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  payment_method?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  payment_status?: string;
  /**
   *
   * @type {object}
   * @memberof Order
   */
  shipping_address?: object;
  /**
   *
   * @type {number}
   * @memberof Order
   */
  shipping_cost?: number;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  status?: string;
  /**
   *
   * @type {number}
   * @memberof Order
   */
  subtotal?: number;
  /**
   *
   * @type {number}
   * @memberof Order
   */
  tax_amount?: number;
  /**
   *
   * @type {number}
   * @memberof Order
   */
  total_amount?: number;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface OrderEdges
 */
export interface OrderEdges {
  /**
   *
   * @type {Clinic}
   * @memberof OrderEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {Array<OrderItem>}
   * @memberof OrderEdges
   */
  order_items?: Array<OrderItem> | null;
  /**
   *
   * @type {Array<OrderStatusHistory>}
   * @memberof OrderEdges
   */
  order_status_history?: Array<OrderStatusHistory> | null;
  /**
   *
   * @type {Patient}
   * @memberof OrderEdges
   */
  patient?: Patient;
}
/**
 *
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof OrderItem
   */
  created_at?: string;
  /**
   *
   * @type {number}
   * @memberof OrderItem
   */
  discount_amount?: number;
  /**
   *
   * @type {OrderItemEdges}
   * @memberof OrderItem
   */
  edges: OrderItemEdges;
  /**
   *
   * @type {string}
   * @memberof OrderItem
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof OrderItem
   */
  item_description?: string;
  /**
   *
   * @type {object}
   * @memberof OrderItem
   */
  item_metadata?: object;
  /**
   *
   * @type {string}
   * @memberof OrderItem
   */
  item_name?: string;
  /**
   *
   * @type {string}
   * @memberof OrderItem
   */
  item_type?: string;
  /**
   *
   * @type {number}
   * @memberof OrderItem
   */
  quantity?: number;
  /**
   *
   * @type {number}
   * @memberof OrderItem
   */
  total_price?: number;
  /**
   *
   * @type {number}
   * @memberof OrderItem
   */
  unit_price?: number;
}
/**
 *
 * @export
 * @interface OrderItemEdges
 */
export interface OrderItemEdges {
  /**
   *
   * @type {Appointment}
   * @memberof OrderItemEdges
   */
  appointment?: Appointment;
  /**
   *
   * @type {Order}
   * @memberof OrderItemEdges
   */
  order?: Order;
  /**
   *
   * @type {Product}
   * @memberof OrderItemEdges
   */
  product?: Product;
  /**
   *
   * @type {Service}
   * @memberof OrderItemEdges
   */
  service?: Service;
}
/**
 *
 * @export
 * @interface OrderStatusHistory
 */
export interface OrderStatusHistory {
  /**
   *
   * @type {string}
   * @memberof OrderStatusHistory
   */
  changed_by?: string;
  /**
   *
   * @type {string}
   * @memberof OrderStatusHistory
   */
  created_at?: string;
  /**
   *
   * @type {OrderStatusHistoryEdges}
   * @memberof OrderStatusHistory
   */
  edges: OrderStatusHistoryEdges;
  /**
   *
   * @type {string}
   * @memberof OrderStatusHistory
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof OrderStatusHistory
   */
  notes?: string;
  /**
   *
   * @type {string}
   * @memberof OrderStatusHistory
   */
  status?: string;
}
/**
 *
 * @export
 * @interface OrderStatusHistoryEdges
 */
export interface OrderStatusHistoryEdges {
  /**
   *
   * @type {Order}
   * @memberof OrderStatusHistoryEdges
   */
  order?: Order;
}
/**
 *
 * @export
 * @interface Patient
 */
export interface Patient {
  [key: string]: any;

  /**
   *
   * @type {boolean}
   * @memberof Patient
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  address?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Patient
   */
  allergies?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  birth_date?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  created_at?: string;
  /**
   *
   * @type {PatientEdges}
   * @memberof Patient
   */
  edges: PatientEdges;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  emergency_contact_name?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  emergency_contact_phone?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  gender?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  id?: string;
  /**
   *
   * @type {object}
   * @memberof Patient
   */
  medical_history?: object;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  phone?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  whatsapp_number?: string;
}
/**
 *
 * @export
 * @interface PatientEdges
 */
export interface PatientEdges {
  /**
   *
   * @type {Array<Appointment>}
   * @memberof PatientEdges
   */
  appointments?: Array<Appointment> | null;
  /**
   *
   * @type {Array<BillingRecord>}
   * @memberof PatientEdges
   */
  billing_records?: Array<BillingRecord> | null;
  /**
   *
   * @type {Array<ChatThread>}
   * @memberof PatientEdges
   */
  chat_threads?: Array<ChatThread> | null;
  /**
   *
   * @type {Clinic}
   * @memberof PatientEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {Array<Document>}
   * @memberof PatientEdges
   */
  documents?: Array<Document> | null;
  /**
   *
   * @type {Array<Order>}
   * @memberof PatientEdges
   */
  orders?: Array<Order> | null;
}
/**
 *
 * @export
 * @interface PingData
 */
export interface PingData {
  /**
   * Ping response message
   * @type {string}
   * @memberof PingData
   */
  message: string;
}
/**
 *
 * @export
 * @interface Product
 */
export interface Product {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof Product
   */
  batch_number?: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  brand?: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  created_at?: string;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  current_stock?: number;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  description?: string;
  /**
   *
   * @type {{ [key: string]: number; }}
   * @memberof Product
   */
  dimensions?: { [key: string]: number };
  /**
   *
   * @type {number}
   * @memberof Product
   */
  discount_price?: number;
  /**
   *
   * @type {ProductEdges}
   * @memberof Product
   */
  edges: ProductEdges;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  expiry_date?: string;
  /**
   *
   * @type {boolean}
   * @memberof Product
   */
  featured?: boolean;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  id?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Product
   */
  images?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  min_stock_level?: number;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof Product
   */
  prescription_required?: boolean;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  purchase_price?: number;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  selling_price?: number;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  short_description?: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  sku?: string;
  /**
   *
   * @type {object}
   * @memberof Product
   */
  specifications?: object;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  status?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Product
   */
  tags?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof Product
   */
  track_inventory?: boolean;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  unit?: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  updated_at?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Product
   */
  usage_instructions?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Product
   */
  warnings?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  weight?: number;
}
/**
 *
 * @export
 * @interface ProductCategory
 */
export interface ProductCategory {
  /**
   *
   * @type {boolean}
   * @memberof ProductCategory
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof ProductCategory
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof ProductCategory
   */
  description?: string;
  /**
   *
   * @type {ProductCategoryEdges}
   * @memberof ProductCategory
   */
  edges: ProductCategoryEdges;
  /**
   *
   * @type {string}
   * @memberof ProductCategory
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductCategory
   */
  image_url?: string;
  /**
   *
   * @type {string}
   * @memberof ProductCategory
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof ProductCategory
   */
  sort_order?: number;
  /**
   *
   * @type {string}
   * @memberof ProductCategory
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface ProductCategoryEdges
 */
export interface ProductCategoryEdges {
  /**
   *
   * @type {Clinic}
   * @memberof ProductCategoryEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {Array<Product>}
   * @memberof ProductCategoryEdges
   */
  products?: Array<Product> | null;
}
/**
 *
 * @export
 * @interface ProductEdges
 */
export interface ProductEdges {
  /**
   *
   * @type {ProductCategory}
   * @memberof ProductEdges
   */
  category?: ProductCategory;
  /**
   *
   * @type {Clinic}
   * @memberof ProductEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {Array<InventoryMovement>}
   * @memberof ProductEdges
   */
  inventory_movements?: Array<InventoryMovement> | null;
  /**
   *
   * @type {Array<OrderItem>}
   * @memberof ProductEdges
   */
  order_items?: Array<OrderItem> | null;
}
/**
 *
 * @export
 * @interface QueueEntry
 */
export interface QueueEntry {
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  called_at?: string;
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  clinic_id?: string;
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  completed_at?: string;
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  doctor_id?: string;
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  estimated_time?: string;
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  notes?: string;
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  patient_id?: string;
  /**
   *
   * @type {number}
   * @memberof QueueEntry
   */
  queue_number?: number;
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  service_id?: string;
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof QueueEntry
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface RefreshOutput
 */
export interface RefreshOutput {
  /**
   *
   * @type {string}
   * @memberof RefreshOutput
   */
  access_token: string;
  /**
   *
   * @type {number}
   * @memberof RefreshOutput
   */
  access_token_expires_at: number;
  /**
   *
   * @type {string}
   * @memberof RefreshOutput
   */
  refresh_token: string;
  /**
   *
   * @type {number}
   * @memberof RefreshOutput
   */
  refresh_token_expires_at: number;
}
/**
 *
 * @export
 * @interface RefreshPayload
 */
export interface RefreshPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof RefreshPayload
   */
  $schema?: string;
  /**
   * The refresh token to use for refreshing the session
   * @type {string}
   * @memberof RefreshPayload
   */
  refresh_token: string;
}
/**
 *
 * @export
 * @interface ResponseCreateAppointmentData
 */
export interface ResponseCreateAppointmentData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseCreateAppointmentData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Appointment}
   * @memberof ResponseCreateAppointmentData
   */
  data: Appointment;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseCreateAppointmentData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseCreateClinicData
 */
export interface ResponseCreateClinicData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseCreateClinicData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Clinic}
   * @memberof ResponseCreateClinicData
   */
  data: Clinic;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseCreateClinicData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseCreateDoctorData
 */
export interface ResponseCreateDoctorData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseCreateDoctorData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Doctor}
   * @memberof ResponseCreateDoctorData
   */
  data: Doctor;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseCreateDoctorData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseCreateFeatureData
 */
export interface ResponseCreateFeatureData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseCreateFeatureData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Feature}
   * @memberof ResponseCreateFeatureData
   */
  data: Feature;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseCreateFeatureData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseCreateOrderData
 */
export interface ResponseCreateOrderData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseCreateOrderData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Order}
   * @memberof ResponseCreateOrderData
   */
  data: Order;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseCreateOrderData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseCreatePatientData
 */
export interface ResponseCreatePatientData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseCreatePatientData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Patient}
   * @memberof ResponseCreatePatientData
   */
  data: Patient;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseCreatePatientData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseCreateProductData
 */
export interface ResponseCreateProductData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseCreateProductData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Product}
   * @memberof ResponseCreateProductData
   */
  data: Product;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseCreateProductData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseCreateQueueEntryData
 */
export interface ResponseCreateQueueEntryData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseCreateQueueEntryData
   */
  $schema?: string;
  /**
   * Response data
   * @type {QueueEntry}
   * @memberof ResponseCreateQueueEntryData
   */
  data: QueueEntry;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseCreateQueueEntryData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseCreateServiceData
 */
export interface ResponseCreateServiceData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseCreateServiceData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Service}
   * @memberof ResponseCreateServiceData
   */
  data: Service;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseCreateServiceData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseCreateUserData
 */
export interface ResponseCreateUserData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseCreateUserData
   */
  $schema?: string;
  /**
   * Response data
   * @type {User}
   * @memberof ResponseCreateUserData
   */
  data: User;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseCreateUserData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseDetailAppointmentData
 */
export interface ResponseDetailAppointmentData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseDetailAppointmentData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Appointment}
   * @memberof ResponseDetailAppointmentData
   */
  data: Appointment;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseDetailAppointmentData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseDetailClinicData
 */
export interface ResponseDetailClinicData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseDetailClinicData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Clinic}
   * @memberof ResponseDetailClinicData
   */
  data: Clinic;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseDetailClinicData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseDetailDoctorData
 */
export interface ResponseDetailDoctorData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseDetailDoctorData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Doctor}
   * @memberof ResponseDetailDoctorData
   */
  data: Doctor;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseDetailDoctorData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseDetailFeatureData
 */
export interface ResponseDetailFeatureData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseDetailFeatureData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Feature}
   * @memberof ResponseDetailFeatureData
   */
  data: Feature;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseDetailFeatureData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseDetailOrderData
 */
export interface ResponseDetailOrderData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseDetailOrderData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Order}
   * @memberof ResponseDetailOrderData
   */
  data: Order;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseDetailOrderData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseDetailPatientData
 */
export interface ResponseDetailPatientData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseDetailPatientData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Patient}
   * @memberof ResponseDetailPatientData
   */
  data: Patient;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseDetailPatientData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseDetailProductData
 */
export interface ResponseDetailProductData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseDetailProductData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Product}
   * @memberof ResponseDetailProductData
   */
  data: Product;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseDetailProductData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseDetailQueueEntryData
 */
export interface ResponseDetailQueueEntryData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseDetailQueueEntryData
   */
  $schema?: string;
  /**
   * Response data
   * @type {QueueEntry}
   * @memberof ResponseDetailQueueEntryData
   */
  data: QueueEntry;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseDetailQueueEntryData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseDetailServiceData
 */
export interface ResponseDetailServiceData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseDetailServiceData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Service}
   * @memberof ResponseDetailServiceData
   */
  data: Service;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseDetailServiceData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseDetailUserData
 */
export interface ResponseDetailUserData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseDetailUserData
   */
  $schema?: string;
  /**
   * Response data
   * @type {User}
   * @memberof ResponseDetailUserData
   */
  data: User;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseDetailUserData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseListAppointmentData
 */
export interface ResponseListAppointmentData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseListAppointmentData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Array<Appointment>}
   * @memberof ResponseListAppointmentData
   */
  data: Array<Appointment> | null;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseListAppointmentData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseListClinicData
 */
export interface ResponseListClinicData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseListClinicData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Array<Clinic>}
   * @memberof ResponseListClinicData
   */
  data: Array<Clinic> | null;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseListClinicData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseListDoctorData
 */
export interface ResponseListDoctorData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseListDoctorData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Array<Doctor>}
   * @memberof ResponseListDoctorData
   */
  data: Array<Doctor> | null;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseListDoctorData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseListFeatureData
 */
export interface ResponseListFeatureData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseListFeatureData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Array<Feature>}
   * @memberof ResponseListFeatureData
   */
  data: Array<Feature> | null;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseListFeatureData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseListOrderData
 */
export interface ResponseListOrderData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseListOrderData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Array<Order>}
   * @memberof ResponseListOrderData
   */
  data: Array<Order> | null;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseListOrderData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseListPatientData
 */
export interface ResponseListPatientData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseListPatientData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Array<Patient>}
   * @memberof ResponseListPatientData
   */
  data: Array<Patient> | null;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseListPatientData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseListProductData
 */
export interface ResponseListProductData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseListProductData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Array<Product>}
   * @memberof ResponseListProductData
   */
  data: Array<Product> | null;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseListProductData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseListQueueEntryData
 */
export interface ResponseListQueueEntryData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseListQueueEntryData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Array<QueueEntry>}
   * @memberof ResponseListQueueEntryData
   */
  data: Array<QueueEntry> | null;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseListQueueEntryData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseListServiceData
 */
export interface ResponseListServiceData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseListServiceData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Array<Service>}
   * @memberof ResponseListServiceData
   */
  data: Array<Service> | null;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseListServiceData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseListUserData
 */
export interface ResponseListUserData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseListUserData
   */
  $schema?: string;
  /**
   * Response data
   * @type {Array<User>}
   * @memberof ResponseListUserData
   */
  data: Array<User> | null;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseListUserData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseLoginAdminData
 */
export interface ResponseLoginAdminData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseLoginAdminData
   */
  $schema?: string;
  /**
   * Response data
   * @type {LoginOutput}
   * @memberof ResponseLoginAdminData
   */
  data: LoginOutput;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseLoginAdminData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseLoginData
 */
export interface ResponseLoginData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseLoginData
   */
  $schema?: string;
  /**
   * Response data
   * @type {LoginOutput}
   * @memberof ResponseLoginData
   */
  data: LoginOutput;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseLoginData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseMessage
 */
export interface ResponseMessage {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseMessage
   */
  $schema?: string;
  /**
   * Response message
   * @type {string}
   * @memberof ResponseMessage
   */
  message: string;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseMessage
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponsePingData
 */
export interface ResponsePingData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponsePingData
   */
  $schema?: string;
  /**
   * Response data
   * @type {PingData}
   * @memberof ResponsePingData
   */
  data: PingData;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponsePingData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface ResponseRefreshData
 */
export interface ResponseRefreshData {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof ResponseRefreshData
   */
  $schema?: string;
  /**
   * Response data
   * @type {RefreshOutput}
   * @memberof ResponseRefreshData
   */
  data: RefreshOutput;
  /**
   * Response metadata
   * @type {Meta}
   * @memberof ResponseRefreshData
   */
  meta: Meta;
}
/**
 *
 * @export
 * @interface Service
 */
export interface Service {
  /**
   *
   * @type {boolean}
   * @memberof Service
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Service
   */
  category?: string;
  /**
   *
   * @type {string}
   * @memberof Service
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Service
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof Service
   */
  duration?: number;
  /**
   *
   * @type {ServiceEdges}
   * @memberof Service
   */
  edges: ServiceEdges;
  /**
   *
   * @type {string}
   * @memberof Service
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Service
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof Service
   */
  price?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Service
   */
  requirements?: Array<string> | null;
  /**
   *
   * @type {boolean}
   * @memberof Service
   */
  requires_appointment?: boolean;
  /**
   *
   * @type {string}
   * @memberof Service
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface ServiceEdges
 */
export interface ServiceEdges {
  /**
   *
   * @type {Array<Appointment>}
   * @memberof ServiceEdges
   */
  appointments?: Array<Appointment> | null;
  /**
   *
   * @type {Clinic}
   * @memberof ServiceEdges
   */
  clinic?: Clinic;
  /**
   *
   * @type {Array<OrderItem>}
   * @memberof ServiceEdges
   */
  order_items?: Array<OrderItem> | null;
}
/**
 *
 * @export
 * @interface Session
 */
export interface Session {
  /**
   *
   * @type {string}
   * @memberof Session
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  device_id?: string;
  /**
   *
   * @type {SessionEdges}
   * @memberof Session
   */
  edges: SessionEdges;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  expires_at?: string;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  ip_address?: string;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  last_used_at?: string;
  /**
   *
   * @type {number}
   * @memberof Session
   */
  number_of_uses?: number;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  refresh_token?: string;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  revoked_at?: string;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  user_agent?: string;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  user_id?: string;
}
/**
 *
 * @export
 * @interface SessionEdges
 */
export interface SessionEdges {
  /**
   *
   * @type {User}
   * @memberof SessionEdges
   */
  user?: User;
}
/**
 *
 * @export
 * @interface UpdateAppointmentPayload
 */
export interface UpdateAppointmentPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof UpdateAppointmentPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface UpdateClinicPayload
 */
export interface UpdateClinicPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof UpdateClinicPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface UpdateDoctorPayload
 */
export interface UpdateDoctorPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof UpdateDoctorPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface UpdateFeaturePayload
 */
export interface UpdateFeaturePayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof UpdateFeaturePayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface UpdateOrderPayload
 */
export interface UpdateOrderPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof UpdateOrderPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface UpdatePatientPayload
 */
export interface UpdatePatientPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof UpdatePatientPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface UpdateProductPayload
 */
export interface UpdateProductPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof UpdateProductPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface UpdateQueueEntryPayload
 */
export interface UpdateQueueEntryPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof UpdateQueueEntryPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface UpdateServicePayload
 */
export interface UpdateServicePayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof UpdateServicePayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface UpdateUserPayload
 */
export interface UpdateUserPayload {
  /**
   * A URL to the JSON Schema for this object.
   * @type {string}
   * @memberof UpdateUserPayload
   */
  $schema?: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  created_at?: string;
  /**
   *
   * @type {UserEdges}
   * @memberof User
   */
  edges: UserEdges;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  phone?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  role?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface UserEdges
 */
export interface UserEdges {
  /**
   *
   * @type {Array<ClinicUser>}
   * @memberof UserEdges
   */
  clinic_users?: Array<ClinicUser> | null;
  /**
   *
   * @type {Array<Session>}
   * @memberof UserEdges
   */
  sessions?: Array<Session> | null;
}

/**
 * AppointmentApi - axios parameter creator
 * @export
 */
export const AppointmentApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a appointment by ID
     * @summary Delete Appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAppointments: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('deleteAppointments', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteAppointments', 'id', id);
      const localVarPath = `/api/appointments`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve a list of appointments
     * @summary List Appointments
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppointments: async (
      xTenantID: string,
      q?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getAppointments', 'xTenantID', xTenantID);
      const localVarPath = `/api/appointments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve details of a appointment by ID
     * @summary Detail Appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppointmentsId: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getAppointmentsId', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getAppointmentsId', 'id', id);
      const localVarPath = `/api/appointments/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update an existing appointment by ID
     * @summary Update appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateAppointmentPayload} updateAppointmentPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchAppointments: async (
      xTenantID: string,
      id: string,
      updateAppointmentPayload: UpdateAppointmentPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('patchAppointments', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('patchAppointments', 'id', id);
      // verify required parameter 'updateAppointmentPayload' is not null or undefined
      assertParamExists(
        'patchAppointments',
        'updateAppointmentPayload',
        updateAppointmentPayload
      );
      const localVarPath = `/api/appointments`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateAppointmentPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new appointment
     * @summary Create Appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateAppointmentPayload} createAppointmentPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAppointments: async (
      xTenantID: string,
      createAppointmentPayload: CreateAppointmentPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('postAppointments', 'xTenantID', xTenantID);
      // verify required parameter 'createAppointmentPayload' is not null or undefined
      assertParamExists(
        'postAppointments',
        'createAppointmentPayload',
        createAppointmentPayload
      );
      const localVarPath = `/api/appointments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createAppointmentPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AppointmentApi - functional programming interface
 * @export
 */
export const AppointmentApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AppointmentApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a appointment by ID
     * @summary Delete Appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAppointments(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAppointments(
          xTenantID,
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AppointmentApi.deleteAppointments']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of appointments
     * @summary List Appointments
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppointments(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseListAppointmentData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAppointments(
        xTenantID,
        q,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AppointmentApi.getAppointments']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve details of a appointment by ID
     * @summary Detail Appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppointmentsId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseDetailAppointmentData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAppointmentsId(
          xTenantID,
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AppointmentApi.getAppointmentsId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update an existing appointment by ID
     * @summary Update appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateAppointmentPayload} updateAppointmentPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchAppointments(
      xTenantID: string,
      id: string,
      updateAppointmentPayload: UpdateAppointmentPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.patchAppointments(
          xTenantID,
          id,
          updateAppointmentPayload,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AppointmentApi.patchAppointments']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new appointment
     * @summary Create Appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateAppointmentPayload} createAppointmentPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postAppointments(
      xTenantID: string,
      createAppointmentPayload: CreateAppointmentPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseCreateAppointmentData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postAppointments(
          xTenantID,
          createAppointmentPayload,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AppointmentApi.postAppointments']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * AppointmentApi - factory interface
 * @export
 */
export const AppointmentApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AppointmentApiFp(configuration);
  return {
    /**
     * Delete a appointment by ID
     * @summary Delete Appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAppointments(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .deleteAppointments(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of appointments
     * @summary List Appointments
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppointments(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseListAppointmentData> {
      return localVarFp
        .getAppointments(xTenantID, q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of a appointment by ID
     * @summary Detail Appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppointmentsId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseDetailAppointmentData> {
      return localVarFp
        .getAppointmentsId(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing appointment by ID
     * @summary Update appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateAppointmentPayload} updateAppointmentPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchAppointments(
      xTenantID: string,
      id: string,
      updateAppointmentPayload: UpdateAppointmentPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .patchAppointments(xTenantID, id, updateAppointmentPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new appointment
     * @summary Create Appointment
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateAppointmentPayload} createAppointmentPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAppointments(
      xTenantID: string,
      createAppointmentPayload: CreateAppointmentPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseCreateAppointmentData> {
      return localVarFp
        .postAppointments(xTenantID, createAppointmentPayload, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * AppointmentApi - object-oriented interface
 * @export
 * @class AppointmentApi
 * @extends {BaseAPI}
 */
export class AppointmentApi extends BaseAPI {
  /**
   * Delete a appointment by ID
   * @summary Delete Appointment
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppointmentApi
   */
  public deleteAppointments(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return AppointmentApiFp(this.configuration)
      .deleteAppointments(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of appointments
   * @summary List Appointments
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} [q] Query parameter for filtering
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppointmentApi
   */
  public getAppointments(
    xTenantID: string,
    q?: string,
    options?: RawAxiosRequestConfig
  ) {
    return AppointmentApiFp(this.configuration)
      .getAppointments(xTenantID, q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve details of a appointment by ID
   * @summary Detail Appointment
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppointmentApi
   */
  public getAppointmentsId(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return AppointmentApiFp(this.configuration)
      .getAppointmentsId(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing appointment by ID
   * @summary Update appointment
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to update
   * @param {UpdateAppointmentPayload} updateAppointmentPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppointmentApi
   */
  public patchAppointments(
    xTenantID: string,
    id: string,
    updateAppointmentPayload: UpdateAppointmentPayload,
    options?: RawAxiosRequestConfig
  ) {
    return AppointmentApiFp(this.configuration)
      .patchAppointments(xTenantID, id, updateAppointmentPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new appointment
   * @summary Create Appointment
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {CreateAppointmentPayload} createAppointmentPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppointmentApi
   */
  public postAppointments(
    xTenantID: string,
    createAppointmentPayload: CreateAppointmentPayload,
    options?: RawAxiosRequestConfig
  ) {
    return AppointmentApiFp(this.configuration)
      .postAppointments(xTenantID, createAppointmentPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Login as an admin user
     * @summary Login Admin
     * @param {LoginAdminPayload} loginAdminPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAdminLogin: async (
      loginAdminPayload: LoginAdminPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginAdminPayload' is not null or undefined
      assertParamExists(
        'postAdminLogin',
        'loginAdminPayload',
        loginAdminPayload
      );
      const localVarPath = `/api/admin/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginAdminPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Login handler
     * @summary Login
     * @param {LoginPayload} loginPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthLogin: async (
      loginPayload: LoginPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginPayload' is not null or undefined
      assertParamExists('postAuthLogin', 'loginPayload', loginPayload);
      const localVarPath = `/api/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Refresh handler
     * @summary Refresh
     * @param {RefreshPayload} refreshPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthRefresh: async (
      refreshPayload: RefreshPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'refreshPayload' is not null or undefined
      assertParamExists('postAuthRefresh', 'refreshPayload', refreshPayload);
      const localVarPath = `/api/auth/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refreshPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     * Login as an admin user
     * @summary Login Admin
     * @param {LoginAdminPayload} loginAdminPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postAdminLogin(
      loginAdminPayload: LoginAdminPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseLoginAdminData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postAdminLogin(
        loginAdminPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.postAdminLogin']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Login handler
     * @summary Login
     * @param {LoginPayload} loginPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postAuthLogin(
      loginPayload: LoginPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseLoginData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthLogin(
        loginPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.postAuthLogin']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Refresh handler
     * @summary Refresh
     * @param {RefreshPayload} refreshPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postAuthRefresh(
      refreshPayload: RefreshPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseRefreshData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthRefresh(
        refreshPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.postAuthRefresh']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     * Login as an admin user
     * @summary Login Admin
     * @param {LoginAdminPayload} loginAdminPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAdminLogin(
      loginAdminPayload: LoginAdminPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseLoginAdminData> {
      return localVarFp
        .postAdminLogin(loginAdminPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Login handler
     * @summary Login
     * @param {LoginPayload} loginPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthLogin(
      loginPayload: LoginPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseLoginData> {
      return localVarFp
        .postAuthLogin(loginPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Refresh handler
     * @summary Refresh
     * @param {RefreshPayload} refreshPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthRefresh(
      refreshPayload: RefreshPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseRefreshData> {
      return localVarFp
        .postAuthRefresh(refreshPayload, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * Login as an admin user
   * @summary Login Admin
   * @param {LoginAdminPayload} loginAdminPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public postAdminLogin(
    loginAdminPayload: LoginAdminPayload,
    options?: RawAxiosRequestConfig
  ) {
    return AuthApiFp(this.configuration)
      .postAdminLogin(loginAdminPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Login handler
   * @summary Login
   * @param {LoginPayload} loginPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public postAuthLogin(
    loginPayload: LoginPayload,
    options?: RawAxiosRequestConfig
  ) {
    return AuthApiFp(this.configuration)
      .postAuthLogin(loginPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Refresh handler
   * @summary Refresh
   * @param {RefreshPayload} refreshPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public postAuthRefresh(
    refreshPayload: RefreshPayload,
    options?: RawAxiosRequestConfig
  ) {
    return AuthApiFp(this.configuration)
      .postAuthRefresh(refreshPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ClinicApi - axios parameter creator
 * @export
 */
export const ClinicApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a clinic by ID
     * @summary Delete Clinic
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClinics: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteClinics', 'id', id);
      const localVarPath = `/api/clinics`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve a list of clinics
     * @summary List Clinics
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClinics: async (
      q?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/clinics`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve details of a clinic by ID
     * @summary Detail Clinic
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClinicsId: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getClinicsId', 'id', id);
      const localVarPath = `/api/clinics/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update an existing clinic by ID
     * @summary Update clinic
     * @param {string} id ID of the item to update
     * @param {UpdateClinicPayload} updateClinicPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchClinics: async (
      id: string,
      updateClinicPayload: UpdateClinicPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('patchClinics', 'id', id);
      // verify required parameter 'updateClinicPayload' is not null or undefined
      assertParamExists(
        'patchClinics',
        'updateClinicPayload',
        updateClinicPayload
      );
      const localVarPath = `/api/clinics`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateClinicPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new clinic
     * @summary Create Clinic
     * @param {CreateClinicPayload} createClinicPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postClinics: async (
      createClinicPayload: CreateClinicPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createClinicPayload' is not null or undefined
      assertParamExists(
        'postClinics',
        'createClinicPayload',
        createClinicPayload
      );
      const localVarPath = `/api/clinics`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createClinicPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ClinicApi - functional programming interface
 * @export
 */
export const ClinicApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ClinicApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a clinic by ID
     * @summary Delete Clinic
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteClinics(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClinics(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ClinicApi.deleteClinics']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of clinics
     * @summary List Clinics
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClinics(
      q?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseListClinicData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getClinics(
        q,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ClinicApi.getClinics']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve details of a clinic by ID
     * @summary Detail Clinic
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClinicsId(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseDetailClinicData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getClinicsId(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ClinicApi.getClinicsId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update an existing clinic by ID
     * @summary Update clinic
     * @param {string} id ID of the item to update
     * @param {UpdateClinicPayload} updateClinicPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchClinics(
      id: string,
      updateClinicPayload: UpdateClinicPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchClinics(
        id,
        updateClinicPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ClinicApi.patchClinics']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new clinic
     * @summary Create Clinic
     * @param {CreateClinicPayload} createClinicPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postClinics(
      createClinicPayload: CreateClinicPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseCreateClinicData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postClinics(
        createClinicPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ClinicApi.postClinics']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * ClinicApi - factory interface
 * @export
 */
export const ClinicApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ClinicApiFp(configuration);
  return {
    /**
     * Delete a clinic by ID
     * @summary Delete Clinic
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClinics(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .deleteClinics(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of clinics
     * @summary List Clinics
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClinics(
      q?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseListClinicData> {
      return localVarFp
        .getClinics(q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of a clinic by ID
     * @summary Detail Clinic
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClinicsId(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseDetailClinicData> {
      return localVarFp
        .getClinicsId(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing clinic by ID
     * @summary Update clinic
     * @param {string} id ID of the item to update
     * @param {UpdateClinicPayload} updateClinicPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchClinics(
      id: string,
      updateClinicPayload: UpdateClinicPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .patchClinics(id, updateClinicPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new clinic
     * @summary Create Clinic
     * @param {CreateClinicPayload} createClinicPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postClinics(
      createClinicPayload: CreateClinicPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseCreateClinicData> {
      return localVarFp
        .postClinics(createClinicPayload, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * ClinicApi - object-oriented interface
 * @export
 * @class ClinicApi
 * @extends {BaseAPI}
 */
export class ClinicApi extends BaseAPI {
  /**
   * Delete a clinic by ID
   * @summary Delete Clinic
   * @param {string} id ID of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicApi
   */
  public deleteClinics(id: string, options?: RawAxiosRequestConfig) {
    return ClinicApiFp(this.configuration)
      .deleteClinics(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of clinics
   * @summary List Clinics
   * @param {string} [q] Query parameter for filtering
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicApi
   */
  public getClinics(q?: string, options?: RawAxiosRequestConfig) {
    return ClinicApiFp(this.configuration)
      .getClinics(q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve details of a clinic by ID
   * @summary Detail Clinic
   * @param {string} id ID of the item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicApi
   */
  public getClinicsId(id: string, options?: RawAxiosRequestConfig) {
    return ClinicApiFp(this.configuration)
      .getClinicsId(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing clinic by ID
   * @summary Update clinic
   * @param {string} id ID of the item to update
   * @param {UpdateClinicPayload} updateClinicPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicApi
   */
  public patchClinics(
    id: string,
    updateClinicPayload: UpdateClinicPayload,
    options?: RawAxiosRequestConfig
  ) {
    return ClinicApiFp(this.configuration)
      .patchClinics(id, updateClinicPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new clinic
   * @summary Create Clinic
   * @param {CreateClinicPayload} createClinicPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicApi
   */
  public postClinics(
    createClinicPayload: CreateClinicPayload,
    options?: RawAxiosRequestConfig
  ) {
    return ClinicApiFp(this.configuration)
      .postClinics(createClinicPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DoctorApi - axios parameter creator
 * @export
 */
export const DoctorApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a doctor by ID
     * @summary Delete Doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDoctors: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('deleteDoctors', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteDoctors', 'id', id);
      const localVarPath = `/api/doctors`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve a list of doctors
     * @summary List Doctors
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctors: async (
      xTenantID: string,
      q?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getDoctors', 'xTenantID', xTenantID);
      const localVarPath = `/api/doctors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve details of a doctor by ID
     * @summary Detail Doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctorsId: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getDoctorsId', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDoctorsId', 'id', id);
      const localVarPath = `/api/doctors/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update an existing doctor by ID
     * @summary Update doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateDoctorPayload} updateDoctorPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDoctors: async (
      xTenantID: string,
      id: string,
      updateDoctorPayload: UpdateDoctorPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('patchDoctors', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('patchDoctors', 'id', id);
      // verify required parameter 'updateDoctorPayload' is not null or undefined
      assertParamExists(
        'patchDoctors',
        'updateDoctorPayload',
        updateDoctorPayload
      );
      const localVarPath = `/api/doctors`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateDoctorPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new doctor
     * @summary Create Doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateDoctorPayload} createDoctorPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDoctors: async (
      xTenantID: string,
      createDoctorPayload: CreateDoctorPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('postDoctors', 'xTenantID', xTenantID);
      // verify required parameter 'createDoctorPayload' is not null or undefined
      assertParamExists(
        'postDoctors',
        'createDoctorPayload',
        createDoctorPayload
      );
      const localVarPath = `/api/doctors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDoctorPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * DoctorApi - functional programming interface
 * @export
 */
export const DoctorApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DoctorApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a doctor by ID
     * @summary Delete Doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDoctors(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDoctors(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoctorApi.deleteDoctors']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of doctors
     * @summary List Doctors
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoctors(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseListDoctorData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoctors(
        xTenantID,
        q,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoctorApi.getDoctors']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve details of a doctor by ID
     * @summary Detail Doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoctorsId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseDetailDoctorData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoctorsId(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoctorApi.getDoctorsId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update an existing doctor by ID
     * @summary Update doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateDoctorPayload} updateDoctorPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchDoctors(
      xTenantID: string,
      id: string,
      updateDoctorPayload: UpdateDoctorPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchDoctors(
        xTenantID,
        id,
        updateDoctorPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoctorApi.patchDoctors']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new doctor
     * @summary Create Doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateDoctorPayload} createDoctorPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDoctors(
      xTenantID: string,
      createDoctorPayload: CreateDoctorPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseCreateDoctorData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postDoctors(
        xTenantID,
        createDoctorPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoctorApi.postDoctors']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * DoctorApi - factory interface
 * @export
 */
export const DoctorApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DoctorApiFp(configuration);
  return {
    /**
     * Delete a doctor by ID
     * @summary Delete Doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDoctors(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .deleteDoctors(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of doctors
     * @summary List Doctors
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctors(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseListDoctorData> {
      return localVarFp
        .getDoctors(xTenantID, q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of a doctor by ID
     * @summary Detail Doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctorsId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseDetailDoctorData> {
      return localVarFp
        .getDoctorsId(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing doctor by ID
     * @summary Update doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateDoctorPayload} updateDoctorPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDoctors(
      xTenantID: string,
      id: string,
      updateDoctorPayload: UpdateDoctorPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .patchDoctors(xTenantID, id, updateDoctorPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new doctor
     * @summary Create Doctor
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateDoctorPayload} createDoctorPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDoctors(
      xTenantID: string,
      createDoctorPayload: CreateDoctorPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseCreateDoctorData> {
      return localVarFp
        .postDoctors(xTenantID, createDoctorPayload, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * DoctorApi - object-oriented interface
 * @export
 * @class DoctorApi
 * @extends {BaseAPI}
 */
export class DoctorApi extends BaseAPI {
  /**
   * Delete a doctor by ID
   * @summary Delete Doctor
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoctorApi
   */
  public deleteDoctors(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return DoctorApiFp(this.configuration)
      .deleteDoctors(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of doctors
   * @summary List Doctors
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} [q] Query parameter for filtering
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoctorApi
   */
  public getDoctors(
    xTenantID: string,
    q?: string,
    options?: RawAxiosRequestConfig
  ) {
    return DoctorApiFp(this.configuration)
      .getDoctors(xTenantID, q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve details of a doctor by ID
   * @summary Detail Doctor
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoctorApi
   */
  public getDoctorsId(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return DoctorApiFp(this.configuration)
      .getDoctorsId(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing doctor by ID
   * @summary Update doctor
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to update
   * @param {UpdateDoctorPayload} updateDoctorPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoctorApi
   */
  public patchDoctors(
    xTenantID: string,
    id: string,
    updateDoctorPayload: UpdateDoctorPayload,
    options?: RawAxiosRequestConfig
  ) {
    return DoctorApiFp(this.configuration)
      .patchDoctors(xTenantID, id, updateDoctorPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new doctor
   * @summary Create Doctor
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {CreateDoctorPayload} createDoctorPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoctorApi
   */
  public postDoctors(
    xTenantID: string,
    createDoctorPayload: CreateDoctorPayload,
    options?: RawAxiosRequestConfig
  ) {
    return DoctorApiFp(this.configuration)
      .postDoctors(xTenantID, createDoctorPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FeatureApi - axios parameter creator
 * @export
 */
export const FeatureApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a feature by ID
     * @summary Delete Feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFeatures: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('deleteFeatures', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteFeatures', 'id', id);
      const localVarPath = `/api/features`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve a list of features
     * @summary List Features
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeatures: async (
      xTenantID: string,
      q?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getFeatures', 'xTenantID', xTenantID);
      const localVarPath = `/api/features`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve details of a feature by ID
     * @summary Detail Feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeaturesId: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getFeaturesId', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFeaturesId', 'id', id);
      const localVarPath = `/api/features/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update an existing feature by ID
     * @summary Update feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateFeaturePayload} updateFeaturePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchFeatures: async (
      xTenantID: string,
      id: string,
      updateFeaturePayload: UpdateFeaturePayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('patchFeatures', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('patchFeatures', 'id', id);
      // verify required parameter 'updateFeaturePayload' is not null or undefined
      assertParamExists(
        'patchFeatures',
        'updateFeaturePayload',
        updateFeaturePayload
      );
      const localVarPath = `/api/features`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateFeaturePayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new feature
     * @summary Create Feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateFeaturePayload} createFeaturePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFeatures: async (
      xTenantID: string,
      createFeaturePayload: CreateFeaturePayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('postFeatures', 'xTenantID', xTenantID);
      // verify required parameter 'createFeaturePayload' is not null or undefined
      assertParamExists(
        'postFeatures',
        'createFeaturePayload',
        createFeaturePayload
      );
      const localVarPath = `/api/features`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createFeaturePayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * FeatureApi - functional programming interface
 * @export
 */
export const FeatureApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FeatureApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a feature by ID
     * @summary Delete Feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFeatures(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeatures(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FeatureApi.deleteFeatures']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of features
     * @summary List Features
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFeatures(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseListFeatureData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatures(
        xTenantID,
        q,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FeatureApi.getFeatures']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve details of a feature by ID
     * @summary Detail Feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFeaturesId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseDetailFeatureData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFeaturesId(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FeatureApi.getFeaturesId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update an existing feature by ID
     * @summary Update feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateFeaturePayload} updateFeaturePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchFeatures(
      xTenantID: string,
      id: string,
      updateFeaturePayload: UpdateFeaturePayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchFeatures(
        xTenantID,
        id,
        updateFeaturePayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FeatureApi.patchFeatures']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new feature
     * @summary Create Feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateFeaturePayload} createFeaturePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postFeatures(
      xTenantID: string,
      createFeaturePayload: CreateFeaturePayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseCreateFeatureData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postFeatures(
        xTenantID,
        createFeaturePayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FeatureApi.postFeatures']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * FeatureApi - factory interface
 * @export
 */
export const FeatureApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FeatureApiFp(configuration);
  return {
    /**
     * Delete a feature by ID
     * @summary Delete Feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFeatures(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .deleteFeatures(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of features
     * @summary List Features
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeatures(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseListFeatureData> {
      return localVarFp
        .getFeatures(xTenantID, q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of a feature by ID
     * @summary Detail Feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeaturesId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseDetailFeatureData> {
      return localVarFp
        .getFeaturesId(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing feature by ID
     * @summary Update feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateFeaturePayload} updateFeaturePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchFeatures(
      xTenantID: string,
      id: string,
      updateFeaturePayload: UpdateFeaturePayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .patchFeatures(xTenantID, id, updateFeaturePayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new feature
     * @summary Create Feature
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateFeaturePayload} createFeaturePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFeatures(
      xTenantID: string,
      createFeaturePayload: CreateFeaturePayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseCreateFeatureData> {
      return localVarFp
        .postFeatures(xTenantID, createFeaturePayload, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * FeatureApi - object-oriented interface
 * @export
 * @class FeatureApi
 * @extends {BaseAPI}
 */
export class FeatureApi extends BaseAPI {
  /**
   * Delete a feature by ID
   * @summary Delete Feature
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeatureApi
   */
  public deleteFeatures(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return FeatureApiFp(this.configuration)
      .deleteFeatures(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of features
   * @summary List Features
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} [q] Query parameter for filtering
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeatureApi
   */
  public getFeatures(
    xTenantID: string,
    q?: string,
    options?: RawAxiosRequestConfig
  ) {
    return FeatureApiFp(this.configuration)
      .getFeatures(xTenantID, q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve details of a feature by ID
   * @summary Detail Feature
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeatureApi
   */
  public getFeaturesId(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return FeatureApiFp(this.configuration)
      .getFeaturesId(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing feature by ID
   * @summary Update feature
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to update
   * @param {UpdateFeaturePayload} updateFeaturePayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeatureApi
   */
  public patchFeatures(
    xTenantID: string,
    id: string,
    updateFeaturePayload: UpdateFeaturePayload,
    options?: RawAxiosRequestConfig
  ) {
    return FeatureApiFp(this.configuration)
      .patchFeatures(xTenantID, id, updateFeaturePayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new feature
   * @summary Create Feature
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {CreateFeaturePayload} createFeaturePayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeatureApi
   */
  public postFeatures(
    xTenantID: string,
    createFeaturePayload: CreateFeaturePayload,
    options?: RawAxiosRequestConfig
  ) {
    return FeatureApiFp(this.configuration)
      .postFeatures(xTenantID, createFeaturePayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a order by ID
     * @summary Delete Order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrders: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('deleteOrders', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteOrders', 'id', id);
      const localVarPath = `/api/orders`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve a list of orders
     * @summary List Orders
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrders: async (
      xTenantID: string,
      q?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getOrders', 'xTenantID', xTenantID);
      const localVarPath = `/api/orders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve details of a order by ID
     * @summary Detail Order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrdersId: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getOrdersId', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getOrdersId', 'id', id);
      const localVarPath = `/api/orders/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update an existing order by ID
     * @summary Update order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateOrderPayload} updateOrderPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchOrders: async (
      xTenantID: string,
      id: string,
      updateOrderPayload: UpdateOrderPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('patchOrders', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('patchOrders', 'id', id);
      // verify required parameter 'updateOrderPayload' is not null or undefined
      assertParamExists(
        'patchOrders',
        'updateOrderPayload',
        updateOrderPayload
      );
      const localVarPath = `/api/orders`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateOrderPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new order
     * @summary Create Order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateOrderPayload} createOrderPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postOrders: async (
      xTenantID: string,
      createOrderPayload: CreateOrderPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('postOrders', 'xTenantID', xTenantID);
      // verify required parameter 'createOrderPayload' is not null or undefined
      assertParamExists('postOrders', 'createOrderPayload', createOrderPayload);
      const localVarPath = `/api/orders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createOrderPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a order by ID
     * @summary Delete Order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOrders(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrders(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['OrderApi.deleteOrders']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of orders
     * @summary List Orders
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrders(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseListOrderData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(
        xTenantID,
        q,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['OrderApi.getOrders']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve details of a order by ID
     * @summary Detail Order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrdersId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseDetailOrderData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersId(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['OrderApi.getOrdersId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update an existing order by ID
     * @summary Update order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateOrderPayload} updateOrderPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOrders(
      xTenantID: string,
      id: string,
      updateOrderPayload: UpdateOrderPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchOrders(
        xTenantID,
        id,
        updateOrderPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['OrderApi.patchOrders']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new order
     * @summary Create Order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateOrderPayload} createOrderPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postOrders(
      xTenantID: string,
      createOrderPayload: CreateOrderPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseCreateOrderData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postOrders(
        xTenantID,
        createOrderPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['OrderApi.postOrders']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OrderApiFp(configuration);
  return {
    /**
     * Delete a order by ID
     * @summary Delete Order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrders(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .deleteOrders(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of orders
     * @summary List Orders
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrders(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseListOrderData> {
      return localVarFp
        .getOrders(xTenantID, q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of a order by ID
     * @summary Detail Order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrdersId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseDetailOrderData> {
      return localVarFp
        .getOrdersId(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing order by ID
     * @summary Update order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateOrderPayload} updateOrderPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchOrders(
      xTenantID: string,
      id: string,
      updateOrderPayload: UpdateOrderPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .patchOrders(xTenantID, id, updateOrderPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new order
     * @summary Create Order
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateOrderPayload} createOrderPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postOrders(
      xTenantID: string,
      createOrderPayload: CreateOrderPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseCreateOrderData> {
      return localVarFp
        .postOrders(xTenantID, createOrderPayload, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
  /**
   * Delete a order by ID
   * @summary Delete Order
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public deleteOrders(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return OrderApiFp(this.configuration)
      .deleteOrders(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of orders
   * @summary List Orders
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} [q] Query parameter for filtering
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public getOrders(
    xTenantID: string,
    q?: string,
    options?: RawAxiosRequestConfig
  ) {
    return OrderApiFp(this.configuration)
      .getOrders(xTenantID, q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve details of a order by ID
   * @summary Detail Order
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public getOrdersId(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return OrderApiFp(this.configuration)
      .getOrdersId(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing order by ID
   * @summary Update order
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to update
   * @param {UpdateOrderPayload} updateOrderPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public patchOrders(
    xTenantID: string,
    id: string,
    updateOrderPayload: UpdateOrderPayload,
    options?: RawAxiosRequestConfig
  ) {
    return OrderApiFp(this.configuration)
      .patchOrders(xTenantID, id, updateOrderPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new order
   * @summary Create Order
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {CreateOrderPayload} createOrderPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public postOrders(
    xTenantID: string,
    createOrderPayload: CreateOrderPayload,
    options?: RawAxiosRequestConfig
  ) {
    return OrderApiFp(this.configuration)
      .postOrders(xTenantID, createOrderPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PatientApi - axios parameter creator
 * @export
 */
export const PatientApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a patient by ID
     * @summary Delete Patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePatients: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('deletePatients', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deletePatients', 'id', id);
      const localVarPath = `/api/patients`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve a list of patients
     * @summary List Patients
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatients: async (
      xTenantID: string,
      q?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getPatients', 'xTenantID', xTenantID);
      const localVarPath = `/api/patients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve details of a patient by ID
     * @summary Detail Patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsId: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getPatientsId', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPatientsId', 'id', id);
      const localVarPath = `/api/patients/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update an existing patient by ID
     * @summary Update patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdatePatientPayload} updatePatientPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchPatients: async (
      xTenantID: string,
      id: string,
      updatePatientPayload: UpdatePatientPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('patchPatients', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('patchPatients', 'id', id);
      // verify required parameter 'updatePatientPayload' is not null or undefined
      assertParamExists(
        'patchPatients',
        'updatePatientPayload',
        updatePatientPayload
      );
      const localVarPath = `/api/patients`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePatientPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new patient
     * @summary Create Patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreatePatientPayload} createPatientPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postPatients: async (
      xTenantID: string,
      createPatientPayload: CreatePatientPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('postPatients', 'xTenantID', xTenantID);
      // verify required parameter 'createPatientPayload' is not null or undefined
      assertParamExists(
        'postPatients',
        'createPatientPayload',
        createPatientPayload
      );
      const localVarPath = `/api/patients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPatientPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * PatientApi - functional programming interface
 * @export
 */
export const PatientApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PatientApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a patient by ID
     * @summary Delete Patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePatients(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePatients(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PatientApi.deletePatients']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of patients
     * @summary List Patients
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPatients(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseListPatientData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPatients(
        xTenantID,
        q,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PatientApi.getPatients']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve details of a patient by ID
     * @summary Detail Patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPatientsId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseDetailPatientData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPatientsId(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PatientApi.getPatientsId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update an existing patient by ID
     * @summary Update patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdatePatientPayload} updatePatientPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchPatients(
      xTenantID: string,
      id: string,
      updatePatientPayload: UpdatePatientPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchPatients(
        xTenantID,
        id,
        updatePatientPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PatientApi.patchPatients']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new patient
     * @summary Create Patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreatePatientPayload} createPatientPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postPatients(
      xTenantID: string,
      createPatientPayload: CreatePatientPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseCreatePatientData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postPatients(
        xTenantID,
        createPatientPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PatientApi.postPatients']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * PatientApi - factory interface
 * @export
 */
export const PatientApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PatientApiFp(configuration);
  return {
    /**
     * Delete a patient by ID
     * @summary Delete Patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePatients(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .deletePatients(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of patients
     * @summary List Patients
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatients(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseListPatientData> {
      return localVarFp
        .getPatients(xTenantID, q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of a patient by ID
     * @summary Detail Patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseDetailPatientData> {
      return localVarFp
        .getPatientsId(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing patient by ID
     * @summary Update patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdatePatientPayload} updatePatientPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchPatients(
      xTenantID: string,
      id: string,
      updatePatientPayload: UpdatePatientPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .patchPatients(xTenantID, id, updatePatientPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new patient
     * @summary Create Patient
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreatePatientPayload} createPatientPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postPatients(
      xTenantID: string,
      createPatientPayload: CreatePatientPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseCreatePatientData> {
      return localVarFp
        .postPatients(xTenantID, createPatientPayload, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * PatientApi - object-oriented interface
 * @export
 * @class PatientApi
 * @extends {BaseAPI}
 */
export class PatientApi extends BaseAPI {
  /**
   * Delete a patient by ID
   * @summary Delete Patient
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public deletePatients(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return PatientApiFp(this.configuration)
      .deletePatients(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of patients
   * @summary List Patients
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} [q] Query parameter for filtering
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public getPatients(
    xTenantID: string,
    q?: string,
    options?: RawAxiosRequestConfig
  ) {
    return PatientApiFp(this.configuration)
      .getPatients(xTenantID, q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve details of a patient by ID
   * @summary Detail Patient
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public getPatientsId(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return PatientApiFp(this.configuration)
      .getPatientsId(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing patient by ID
   * @summary Update patient
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to update
   * @param {UpdatePatientPayload} updatePatientPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public patchPatients(
    xTenantID: string,
    id: string,
    updatePatientPayload: UpdatePatientPayload,
    options?: RawAxiosRequestConfig
  ) {
    return PatientApiFp(this.configuration)
      .patchPatients(xTenantID, id, updatePatientPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new patient
   * @summary Create Patient
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {CreatePatientPayload} createPatientPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public postPatients(
    xTenantID: string,
    createPatientPayload: CreatePatientPayload,
    options?: RawAxiosRequestConfig
  ) {
    return PatientApiFp(this.configuration)
      .postPatients(xTenantID, createPatientPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a product by ID
     * @summary Delete Product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProducts: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('deleteProducts', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteProducts', 'id', id);
      const localVarPath = `/api/products`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve a list of products
     * @summary List Products
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProducts: async (
      xTenantID: string,
      q?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getProducts', 'xTenantID', xTenantID);
      const localVarPath = `/api/products`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve details of a product by ID
     * @summary Detail Product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductsId: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getProductsId', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getProductsId', 'id', id);
      const localVarPath = `/api/products/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update an existing product by ID
     * @summary Update product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateProductPayload} updateProductPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchProducts: async (
      xTenantID: string,
      id: string,
      updateProductPayload: UpdateProductPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('patchProducts', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('patchProducts', 'id', id);
      // verify required parameter 'updateProductPayload' is not null or undefined
      assertParamExists(
        'patchProducts',
        'updateProductPayload',
        updateProductPayload
      );
      const localVarPath = `/api/products`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateProductPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new product
     * @summary Create Product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateProductPayload} createProductPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postProducts: async (
      xTenantID: string,
      createProductPayload: CreateProductPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('postProducts', 'xTenantID', xTenantID);
      // verify required parameter 'createProductPayload' is not null or undefined
      assertParamExists(
        'postProducts',
        'createProductPayload',
        createProductPayload
      );
      const localVarPath = `/api/products`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createProductPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a product by ID
     * @summary Delete Product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProducts(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProducts(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.deleteProducts']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of products
     * @summary List Products
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProducts(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseListProductData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(
        xTenantID,
        q,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.getProducts']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve details of a product by ID
     * @summary Detail Product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProductsId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseDetailProductData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsId(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.getProductsId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update an existing product by ID
     * @summary Update product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateProductPayload} updateProductPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchProducts(
      xTenantID: string,
      id: string,
      updateProductPayload: UpdateProductPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchProducts(
        xTenantID,
        id,
        updateProductPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.patchProducts']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new product
     * @summary Create Product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateProductPayload} createProductPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postProducts(
      xTenantID: string,
      createProductPayload: CreateProductPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseCreateProductData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postProducts(
        xTenantID,
        createProductPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.postProducts']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProductApiFp(configuration);
  return {
    /**
     * Delete a product by ID
     * @summary Delete Product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProducts(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .deleteProducts(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of products
     * @summary List Products
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProducts(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseListProductData> {
      return localVarFp
        .getProducts(xTenantID, q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of a product by ID
     * @summary Detail Product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductsId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseDetailProductData> {
      return localVarFp
        .getProductsId(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing product by ID
     * @summary Update product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateProductPayload} updateProductPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchProducts(
      xTenantID: string,
      id: string,
      updateProductPayload: UpdateProductPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .patchProducts(xTenantID, id, updateProductPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new product
     * @summary Create Product
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateProductPayload} createProductPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postProducts(
      xTenantID: string,
      createProductPayload: CreateProductPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseCreateProductData> {
      return localVarFp
        .postProducts(xTenantID, createProductPayload, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
  /**
   * Delete a product by ID
   * @summary Delete Product
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public deleteProducts(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return ProductApiFp(this.configuration)
      .deleteProducts(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of products
   * @summary List Products
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} [q] Query parameter for filtering
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public getProducts(
    xTenantID: string,
    q?: string,
    options?: RawAxiosRequestConfig
  ) {
    return ProductApiFp(this.configuration)
      .getProducts(xTenantID, q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve details of a product by ID
   * @summary Detail Product
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public getProductsId(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return ProductApiFp(this.configuration)
      .getProductsId(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing product by ID
   * @summary Update product
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to update
   * @param {UpdateProductPayload} updateProductPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public patchProducts(
    xTenantID: string,
    id: string,
    updateProductPayload: UpdateProductPayload,
    options?: RawAxiosRequestConfig
  ) {
    return ProductApiFp(this.configuration)
      .patchProducts(xTenantID, id, updateProductPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new product
   * @summary Create Product
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {CreateProductPayload} createProductPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public postProducts(
    xTenantID: string,
    createProductPayload: CreateProductPayload,
    options?: RawAxiosRequestConfig
  ) {
    return ProductApiFp(this.configuration)
      .postProducts(xTenantID, createProductPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * QueueEntryApi - axios parameter creator
 * @export
 */
export const QueueEntryApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a queueentry by ID
     * @summary Delete QueueEntry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueueEntrys: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('deleteQueueEntrys', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteQueueEntrys', 'id', id);
      const localVarPath = `/api/queue-entrys`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve a list of queueentrys
     * @summary List QueueEntrys
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueueEntrys: async (
      xTenantID: string,
      q?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getQueueEntrys', 'xTenantID', xTenantID);
      const localVarPath = `/api/queue-entrys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve details of a queueentry by ID
     * @summary Detail QueueEntry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueueEntrysId: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getQueueEntrysId', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueueEntrysId', 'id', id);
      const localVarPath = `/api/queue-entrys/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update an existing queueentry by ID
     * @summary Update queueentry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateQueueEntryPayload} updateQueueEntryPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchQueueEntrys: async (
      xTenantID: string,
      id: string,
      updateQueueEntryPayload: UpdateQueueEntryPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('patchQueueEntrys', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('patchQueueEntrys', 'id', id);
      // verify required parameter 'updateQueueEntryPayload' is not null or undefined
      assertParamExists(
        'patchQueueEntrys',
        'updateQueueEntryPayload',
        updateQueueEntryPayload
      );
      const localVarPath = `/api/queue-entrys`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateQueueEntryPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new queueentry
     * @summary Create QueueEntry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateQueueEntryPayload} createQueueEntryPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postQueueEntrys: async (
      xTenantID: string,
      createQueueEntryPayload: CreateQueueEntryPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('postQueueEntrys', 'xTenantID', xTenantID);
      // verify required parameter 'createQueueEntryPayload' is not null or undefined
      assertParamExists(
        'postQueueEntrys',
        'createQueueEntryPayload',
        createQueueEntryPayload
      );
      const localVarPath = `/api/queue-entrys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createQueueEntryPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * QueueEntryApi - functional programming interface
 * @export
 */
export const QueueEntryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    QueueEntryApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a queueentry by ID
     * @summary Delete QueueEntry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteQueueEntrys(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteQueueEntrys(
          xTenantID,
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueueEntryApi.deleteQueueEntrys']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of queueentrys
     * @summary List QueueEntrys
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueueEntrys(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseListQueueEntryData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueEntrys(
        xTenantID,
        q,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueueEntryApi.getQueueEntrys']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve details of a queueentry by ID
     * @summary Detail QueueEntry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueueEntrysId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseDetailQueueEntryData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQueueEntrysId(
          xTenantID,
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueueEntryApi.getQueueEntrysId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update an existing queueentry by ID
     * @summary Update queueentry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateQueueEntryPayload} updateQueueEntryPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchQueueEntrys(
      xTenantID: string,
      id: string,
      updateQueueEntryPayload: UpdateQueueEntryPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.patchQueueEntrys(
          xTenantID,
          id,
          updateQueueEntryPayload,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueueEntryApi.patchQueueEntrys']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new queueentry
     * @summary Create QueueEntry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateQueueEntryPayload} createQueueEntryPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postQueueEntrys(
      xTenantID: string,
      createQueueEntryPayload: CreateQueueEntryPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseCreateQueueEntryData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postQueueEntrys(
        xTenantID,
        createQueueEntryPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueueEntryApi.postQueueEntrys']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * QueueEntryApi - factory interface
 * @export
 */
export const QueueEntryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = QueueEntryApiFp(configuration);
  return {
    /**
     * Delete a queueentry by ID
     * @summary Delete QueueEntry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueueEntrys(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .deleteQueueEntrys(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of queueentrys
     * @summary List QueueEntrys
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueueEntrys(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseListQueueEntryData> {
      return localVarFp
        .getQueueEntrys(xTenantID, q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of a queueentry by ID
     * @summary Detail QueueEntry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueueEntrysId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseDetailQueueEntryData> {
      return localVarFp
        .getQueueEntrysId(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing queueentry by ID
     * @summary Update queueentry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateQueueEntryPayload} updateQueueEntryPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchQueueEntrys(
      xTenantID: string,
      id: string,
      updateQueueEntryPayload: UpdateQueueEntryPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .patchQueueEntrys(xTenantID, id, updateQueueEntryPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new queueentry
     * @summary Create QueueEntry
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateQueueEntryPayload} createQueueEntryPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postQueueEntrys(
      xTenantID: string,
      createQueueEntryPayload: CreateQueueEntryPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseCreateQueueEntryData> {
      return localVarFp
        .postQueueEntrys(xTenantID, createQueueEntryPayload, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * QueueEntryApi - object-oriented interface
 * @export
 * @class QueueEntryApi
 * @extends {BaseAPI}
 */
export class QueueEntryApi extends BaseAPI {
  /**
   * Delete a queueentry by ID
   * @summary Delete QueueEntry
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueEntryApi
   */
  public deleteQueueEntrys(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return QueueEntryApiFp(this.configuration)
      .deleteQueueEntrys(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of queueentrys
   * @summary List QueueEntrys
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} [q] Query parameter for filtering
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueEntryApi
   */
  public getQueueEntrys(
    xTenantID: string,
    q?: string,
    options?: RawAxiosRequestConfig
  ) {
    return QueueEntryApiFp(this.configuration)
      .getQueueEntrys(xTenantID, q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve details of a queueentry by ID
   * @summary Detail QueueEntry
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueEntryApi
   */
  public getQueueEntrysId(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return QueueEntryApiFp(this.configuration)
      .getQueueEntrysId(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing queueentry by ID
   * @summary Update queueentry
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to update
   * @param {UpdateQueueEntryPayload} updateQueueEntryPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueEntryApi
   */
  public patchQueueEntrys(
    xTenantID: string,
    id: string,
    updateQueueEntryPayload: UpdateQueueEntryPayload,
    options?: RawAxiosRequestConfig
  ) {
    return QueueEntryApiFp(this.configuration)
      .patchQueueEntrys(xTenantID, id, updateQueueEntryPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new queueentry
   * @summary Create QueueEntry
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {CreateQueueEntryPayload} createQueueEntryPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueEntryApi
   */
  public postQueueEntrys(
    xTenantID: string,
    createQueueEntryPayload: CreateQueueEntryPayload,
    options?: RawAxiosRequestConfig
  ) {
    return QueueEntryApiFp(this.configuration)
      .postQueueEntrys(xTenantID, createQueueEntryPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ServiceApi - axios parameter creator
 * @export
 */
export const ServiceApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a service by ID
     * @summary Delete Service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteServices: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('deleteServices', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteServices', 'id', id);
      const localVarPath = `/api/services`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve a list of services
     * @summary List Services
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServices: async (
      xTenantID: string,
      q?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getServices', 'xTenantID', xTenantID);
      const localVarPath = `/api/services`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve details of a service by ID
     * @summary Detail Service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServicesId: async (
      xTenantID: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('getServicesId', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getServicesId', 'id', id);
      const localVarPath = `/api/services/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update an existing service by ID
     * @summary Update service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateServicePayload} updateServicePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchServices: async (
      xTenantID: string,
      id: string,
      updateServicePayload: UpdateServicePayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('patchServices', 'xTenantID', xTenantID);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('patchServices', 'id', id);
      // verify required parameter 'updateServicePayload' is not null or undefined
      assertParamExists(
        'patchServices',
        'updateServicePayload',
        updateServicePayload
      );
      const localVarPath = `/api/services`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateServicePayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new service
     * @summary Create Service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateServicePayload} createServicePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postServices: async (
      xTenantID: string,
      createServicePayload: CreateServicePayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTenantID' is not null or undefined
      assertParamExists('postServices', 'xTenantID', xTenantID);
      // verify required parameter 'createServicePayload' is not null or undefined
      assertParamExists(
        'postServices',
        'createServicePayload',
        createServicePayload
      );
      const localVarPath = `/api/services`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xTenantID != null) {
        localVarHeaderParameter['X-Tenant-ID'] = String(xTenantID);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createServicePayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ServiceApi - functional programming interface
 * @export
 */
export const ServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ServiceApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a service by ID
     * @summary Delete Service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteServices(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServices(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServiceApi.deleteServices']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of services
     * @summary List Services
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServices(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseListServiceData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServices(
        xTenantID,
        q,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServiceApi.getServices']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve details of a service by ID
     * @summary Detail Service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServicesId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseDetailServiceData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServicesId(
        xTenantID,
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServiceApi.getServicesId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update an existing service by ID
     * @summary Update service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateServicePayload} updateServicePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchServices(
      xTenantID: string,
      id: string,
      updateServicePayload: UpdateServicePayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchServices(
        xTenantID,
        id,
        updateServicePayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServiceApi.patchServices']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new service
     * @summary Create Service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateServicePayload} createServicePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postServices(
      xTenantID: string,
      createServicePayload: CreateServicePayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseCreateServiceData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postServices(
        xTenantID,
        createServicePayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServiceApi.postServices']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * ServiceApi - factory interface
 * @export
 */
export const ServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ServiceApiFp(configuration);
  return {
    /**
     * Delete a service by ID
     * @summary Delete Service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteServices(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .deleteServices(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of services
     * @summary List Services
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServices(
      xTenantID: string,
      q?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseListServiceData> {
      return localVarFp
        .getServices(xTenantID, q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of a service by ID
     * @summary Detail Service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServicesId(
      xTenantID: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseDetailServiceData> {
      return localVarFp
        .getServicesId(xTenantID, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing service by ID
     * @summary Update service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {string} id ID of the item to update
     * @param {UpdateServicePayload} updateServicePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchServices(
      xTenantID: string,
      id: string,
      updateServicePayload: UpdateServicePayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .patchServices(xTenantID, id, updateServicePayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new service
     * @summary Create Service
     * @param {string} xTenantID The tenant ID for scoping the request
     * @param {CreateServicePayload} createServicePayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postServices(
      xTenantID: string,
      createServicePayload: CreateServicePayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseCreateServiceData> {
      return localVarFp
        .postServices(xTenantID, createServicePayload, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * ServiceApi - object-oriented interface
 * @export
 * @class ServiceApi
 * @extends {BaseAPI}
 */
export class ServiceApi extends BaseAPI {
  /**
   * Delete a service by ID
   * @summary Delete Service
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServiceApi
   */
  public deleteServices(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return ServiceApiFp(this.configuration)
      .deleteServices(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of services
   * @summary List Services
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} [q] Query parameter for filtering
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServiceApi
   */
  public getServices(
    xTenantID: string,
    q?: string,
    options?: RawAxiosRequestConfig
  ) {
    return ServiceApiFp(this.configuration)
      .getServices(xTenantID, q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve details of a service by ID
   * @summary Detail Service
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServiceApi
   */
  public getServicesId(
    xTenantID: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return ServiceApiFp(this.configuration)
      .getServicesId(xTenantID, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing service by ID
   * @summary Update service
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {string} id ID of the item to update
   * @param {UpdateServicePayload} updateServicePayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServiceApi
   */
  public patchServices(
    xTenantID: string,
    id: string,
    updateServicePayload: UpdateServicePayload,
    options?: RawAxiosRequestConfig
  ) {
    return ServiceApiFp(this.configuration)
      .patchServices(xTenantID, id, updateServicePayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new service
   * @summary Create Service
   * @param {string} xTenantID The tenant ID for scoping the request
   * @param {CreateServicePayload} createServicePayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServiceApi
   */
  public postServices(
    xTenantID: string,
    createServicePayload: CreateServicePayload,
    options?: RawAxiosRequestConfig
  ) {
    return ServiceApiFp(this.configuration)
      .postServices(xTenantID, createServicePayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Health handler
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHealth: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Ping handler
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPing: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration);
  return {
    /**
     * Health handler
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHealth(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getHealth(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['SystemApi.getHealth']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Ping handler
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPing(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponsePingData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPing(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['SystemApi.getPing']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SystemApiFp(configuration);
  return {
    /**
     * Health handler
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHealth(options?: RawAxiosRequestConfig): AxiosPromise<ResponseMessage> {
      return localVarFp
        .getHealth(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Ping handler
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPing(options?: RawAxiosRequestConfig): AxiosPromise<ResponsePingData> {
      return localVarFp
        .getPing(options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   * Health handler
   * @summary Health
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public getHealth(options?: RawAxiosRequestConfig) {
    return SystemApiFp(this.configuration)
      .getHealth(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Ping handler
   * @summary Ping
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public getPing(options?: RawAxiosRequestConfig) {
    return SystemApiFp(this.configuration)
      .getPing(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a user by ID
     * @summary Delete User
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUsers: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteUsers', 'id', id);
      const localVarPath = `/api/users`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve a list of users
     * @summary List Users
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      q?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve details of a user by ID
     * @summary Detail User
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersId: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getUsersId', 'id', id);
      const localVarPath = `/api/users/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update an existing user by ID
     * @summary Update user
     * @param {string} id ID of the item to update
     * @param {UpdateUserPayload} updateUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchUsers: async (
      id: string,
      updateUserPayload: UpdateUserPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('patchUsers', 'id', id);
      // verify required parameter 'updateUserPayload' is not null or undefined
      assertParamExists('patchUsers', 'updateUserPayload', updateUserPayload);
      const localVarPath = `/api/users`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateUserPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new user
     * @summary Create User
     * @param {CreateUserPayload} createUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUsers: async (
      createUserPayload: CreateUserPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createUserPayload' is not null or undefined
      assertParamExists('postUsers', 'createUserPayload', createUserPayload);
      const localVarPath = `/api/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUserPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a user by ID
     * @summary Delete User
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUsers(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsers(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.deleteUsers']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of users
     * @summary List Users
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      q?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseListUserData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        q,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.getUsers']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve details of a user by ID
     * @summary Detail User
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersId(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseDetailUserData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersId(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.getUsersId']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update an existing user by ID
     * @summary Update user
     * @param {string} id ID of the item to update
     * @param {UpdateUserPayload} updateUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchUsers(
      id: string,
      updateUserPayload: UpdateUserPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchUsers(
        id,
        updateUserPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.patchUsers']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new user
     * @summary Create User
     * @param {CreateUserPayload} createUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUsers(
      createUserPayload: CreateUserPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseCreateUserData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postUsers(
        createUserPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.postUsers']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     * Delete a user by ID
     * @summary Delete User
     * @param {string} id ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUsers(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .deleteUsers(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of users
     * @summary List Users
     * @param {string} [q] Query parameter for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(
      q?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseListUserData> {
      return localVarFp
        .getUsers(q, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of a user by ID
     * @summary Detail User
     * @param {string} id ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersId(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseDetailUserData> {
      return localVarFp
        .getUsersId(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing user by ID
     * @summary Update user
     * @param {string} id ID of the item to update
     * @param {UpdateUserPayload} updateUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchUsers(
      id: string,
      updateUserPayload: UpdateUserPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseMessage> {
      return localVarFp
        .patchUsers(id, updateUserPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new user
     * @summary Create User
     * @param {CreateUserPayload} createUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUsers(
      createUserPayload: CreateUserPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ResponseCreateUserData> {
      return localVarFp
        .postUsers(createUserPayload, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * Delete a user by ID
   * @summary Delete User
   * @param {string} id ID of the item to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public deleteUsers(id: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .deleteUsers(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of users
   * @summary List Users
   * @param {string} [q] Query parameter for filtering
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUsers(q?: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUsers(q, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve details of a user by ID
   * @summary Detail User
   * @param {string} id ID of the item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUsersId(id: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUsersId(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing user by ID
   * @summary Update user
   * @param {string} id ID of the item to update
   * @param {UpdateUserPayload} updateUserPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public patchUsers(
    id: string,
    updateUserPayload: UpdateUserPayload,
    options?: RawAxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .patchUsers(id, updateUserPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new user
   * @summary Create User
   * @param {CreateUserPayload} createUserPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public postUsers(
    createUserPayload: CreateUserPayload,
    options?: RawAxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .postUsers(createUserPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
